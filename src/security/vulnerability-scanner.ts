/**
 * Vulnerability Scanner — scans current and recommended dependencies for
 * known security vulnerabilities using the OSV database.
 *
 * Unlike Snyk/Dependabot which only scan existing deps, Next-Unicorn also
 * scans recommended replacement libraries before adoption — preventing
 * "upgrade into a vulnerability" scenarios.
 *
 * Requirements: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6
 */

import type { RecommendedChange, VulnSeverity } from '../schemas/output.schema.js';
import type { VulnerabilityClient, VulnerabilityRecord } from './osv-client.js';
import { vulnMapKey } from './osv-client.js';

// ---------------------------------------------------------------------------
// Public interfaces
// ---------------------------------------------------------------------------

export type VulnTarget = 'current' | 'recommended' | 'both';

export interface VulnScanInput {
  /** Current project dependencies: name -> version */
  currentLibraries: Record<string, string>;
  /** Recommended libraries from the pipeline */
  recommendedChanges: RecommendedChange[];
  /** Which deps to scan */
  target: VulnTarget;
  /** Default ecosystem to use when workspace info is unavailable */
  defaultEcosystem: string;
  /** Minimum severity to include in results */
  minimumSeverity?: VulnSeverity;
}

export interface VulnFinding {
  /** "current" = existing dep, "recommended" = library we're suggesting */
  source: 'current' | 'recommended';
  packageName: string;
  installedVersion: string;
  ecosystem: string;
  vulnerability: VulnerabilityRecord;
  /** If a fix exists, the version to upgrade to */
  fixAvailable: string | null;
  /** If source is "recommended", index into recommendedChanges[] */
  recommendationIndex?: number;
}

export interface VulnScanResult {
  findings: VulnFinding[];
  summary: {
    totalDepsScanned: number;
    currentDepsScanned: number;
    recommendedDepsScanned: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    fixable: number;
    unfixable: number;
  };
  /** true if VulnerabilityClient was unreachable */
  serviceUnavailable: boolean;
}

// ---------------------------------------------------------------------------
// Severity ordering
// ---------------------------------------------------------------------------

const SEVERITY_ORDER: Record<string, number> = {
  critical: 4,
  high: 3,
  medium: 2,
  low: 1,
  unknown: 0,
};

/**
 * Check if a severity level meets the minimum threshold.
 */
function meetsSeverityThreshold(
  severity: string,
  minimum: string | undefined,
): boolean {
  if (!minimum) return true;
  return (SEVERITY_ORDER[severity] ?? 0) >= (SEVERITY_ORDER[minimum] ?? 0);
}

// ---------------------------------------------------------------------------
// scanVulnerabilities — main entry point
// ---------------------------------------------------------------------------

/**
 * Scan dependencies for known vulnerabilities.
 *
 * Flow:
 * 1. Build query list from currentLibraries + recommendedChanges
 * 2. Batch-query OSV via VulnerabilityClient
 * 3. Filter by minimumSeverity
 * 4. Build VulnFinding[] with fix suggestions
 * 5. Compute summary statistics
 */
export async function scanVulnerabilities(
  input: VulnScanInput,
  client: VulnerabilityClient,
): Promise<VulnScanResult> {
  const { currentLibraries, recommendedChanges, target, defaultEcosystem, minimumSeverity } = input;

  // Build query list
  const queries: Array<{
    ecosystem: string;
    packageName: string;
    version: string;
    source: 'current' | 'recommended';
    recommendationIndex?: number;
  }> = [];

  let currentDepsScanned = 0;
  let recommendedDepsScanned = 0;

  // Current dependencies
  if (target === 'current' || target === 'both') {
    for (const [name, version] of Object.entries(currentLibraries)) {
      queries.push({
        ecosystem: defaultEcosystem,
        packageName: name,
        version,
        source: 'current',
      });
      currentDepsScanned++;
    }
  }

  // Recommended dependencies
  if (target === 'recommended' || target === 'both') {
    for (let i = 0; i < recommendedChanges.length; i++) {
      const rec = recommendedChanges[i]!;
      queries.push({
        ecosystem: defaultEcosystem,
        packageName: rec.recommendedLibrary.name,
        version: rec.recommendedLibrary.version,
        source: 'recommended',
        recommendationIndex: i,
      });
      recommendedDepsScanned++;
    }
  }

  // Batch query
  let vulnMap: Map<string, VulnerabilityRecord[]>;
  let serviceUnavailable = false;

  try {
    vulnMap = await client.queryBatch(
      queries.map((q) => ({
        ecosystem: q.ecosystem,
        packageName: q.packageName,
        version: q.version,
      })),
    );
  } catch {
    // Service unavailable — return empty findings
    return {
      findings: [],
      summary: {
        totalDepsScanned: currentDepsScanned + recommendedDepsScanned,
        currentDepsScanned,
        recommendedDepsScanned,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        fixable: 0,
        unfixable: 0,
      },
      serviceUnavailable: true,
    };
  }

  // Build findings
  const findings: VulnFinding[] = [];

  for (const query of queries) {
    const key = vulnMapKey(query.ecosystem, query.packageName);
    const vulns = vulnMap.get(key) ?? [];

    for (const vuln of vulns) {
      // Skip withdrawn vulnerabilities
      if (vuln.withdrawnAt !== null) continue;

      // Severity filter
      if (!meetsSeverityThreshold(vuln.severity, minimumSeverity)) continue;

      findings.push({
        source: query.source,
        packageName: query.packageName,
        installedVersion: query.version,
        ecosystem: query.ecosystem,
        vulnerability: vuln,
        fixAvailable: vuln.fixedVersion,
        recommendationIndex: query.recommendationIndex,
      });
    }
  }

  // Compute summary
  const summary = {
    totalDepsScanned: currentDepsScanned + recommendedDepsScanned,
    currentDepsScanned,
    recommendedDepsScanned,
    critical: findings.filter((f) => f.vulnerability.severity === 'critical').length,
    high: findings.filter((f) => f.vulnerability.severity === 'high').length,
    medium: findings.filter((f) => f.vulnerability.severity === 'medium').length,
    low: findings.filter((f) => f.vulnerability.severity === 'low').length,
    fixable: findings.filter((f) => f.fixAvailable !== null).length,
    unfixable: findings.filter((f) => f.fixAvailable === null).length,
  };

  return { findings, summary, serviceUnavailable };
}
