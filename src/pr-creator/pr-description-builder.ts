/**
 * PR Description Builder â€” generates rich markdown PR descriptions
 * and titles following conventional commit format.
 *
 * Requirements: 12.4, 12.6
 */

import type { PRPlan, PRItemKind } from './pr-strategy.js';

// ---------------------------------------------------------------------------
// buildPRTitle
// ---------------------------------------------------------------------------

/**
 * Build a PR title following conventional commit format.
 * Property 28: PR title follows conventional commit format.
 *
 * Examples:
 * - "fix(deps): upgrade lodash 4.17.20 -> 4.17.21 (CVE-2026-12345)"
 * - "chore(deps): update @types/react 18.2.0 -> 18.3.1"
 * - "refactor(i18n): replace hand-rolled i18n with next-intl"
 * - "fix(security): patch 3 critical vulnerabilities"
 */
export function buildPRTitle(plan: PRPlan): string {
  switch (plan.type) {
    case 'security-update': {
      const items = plan.items.filter(
        (i): i is Extract<PRItemKind, { kind: 'security' }> => i.kind === 'security',
      );
      if (items.length === 1) {
        const u = items[0]!.update;
        return `fix(deps): upgrade ${u.packageName} ${u.currentVersion} -> ${u.targetVersion}`;
      }
      return `fix(security): patch ${items.length} vulnerabilities`;
    }

    case 'dependency-update': {
      const items = plan.items.filter(
        (i): i is Extract<PRItemKind, { kind: 'update' }> => i.kind === 'update',
      );
      if (items.length === 1) {
        const u = items[0]!.update;
        return `chore(deps): update ${u.packageName} ${u.currentVersion} -> ${u.targetVersion}`;
      }
      return `chore(deps): update ${items.length} dependencies`;
    }

    case 'grouped-update': {
      const items = plan.items.filter(
        (i): i is Extract<PRItemKind, { kind: 'update' }> => i.kind === 'update',
      );
      if (items.length > 0) {
        const groupKey = items[0]!.update.groupKey ?? 'deps';
        return `chore(deps): update ${groupKey} packages (${items.length} updates)`;
      }
      return `chore(deps): update dependency group`;
    }

    case 'migration': {
      const items = plan.items.filter(
        (i): i is Extract<PRItemKind, { kind: 'migration' }> => i.kind === 'migration',
      );
      if (items.length === 1) {
        const rec = items[0]!.recommendation;
        return `refactor(${rec.domain}): replace ${rec.currentImplementation.patternCategory} with ${rec.recommendedLibrary.name}`;
      }
      const phase = items[0]?.phaseNumber ?? 1;
      return `refactor: migration phase ${phase} (${items.length} changes)`;
    }

    default:
      return `chore: next-unicorn update`;
  }
}

// ---------------------------------------------------------------------------
// buildPRDescription
// ---------------------------------------------------------------------------

/**
 * Build a rich markdown PR description with embedded analysis.
 */
export function buildPRDescription(plan: PRPlan): string {
  const sections: string[] = [];

  // Header
  sections.push(`## ${getPRTypeEmoji(plan.type)} ${getPRTypeLabel(plan.type)}`);
  sections.push('');

  // Summary
  sections.push(buildSummarySection(plan));
  sections.push('');

  // Details per item type
  for (const item of plan.items) {
    switch (item.kind) {
      case 'security':
        sections.push(buildSecurityItemSection(item));
        break;
      case 'update':
        sections.push(buildUpdateItemSection(item));
        break;
      case 'migration':
        sections.push(buildMigrationItemSection(item));
        break;
    }
    sections.push('');
  }

  // Reviewer checklist
  sections.push('## Checklist');
  sections.push('');
  sections.push('- [ ] Review changes and verify correctness');
  sections.push('- [ ] Run test suite');

  if (plan.type === 'migration') {
    sections.push('- [ ] Verify adapter strategy works correctly');
    sections.push('- [ ] Check for regressions in affected areas');
  }

  if (plan.type === 'security-update') {
    sections.push('- [ ] Verify vulnerability is patched');
    sections.push('- [ ] Check for breaking changes from the upgrade');
  }

  sections.push('- [ ] Run `pnpm install` to regenerate lockfile');
  sections.push('');

  // Footer
  sections.push('---');
  sections.push('*Auto-generated by [Next-Unicorn](https://github.com/TsekaLuk/Next-Unicorn-Skill) SKILL*');

  return sections.join('\n');
}

// ---------------------------------------------------------------------------
// Internal helpers
// ---------------------------------------------------------------------------

function getPRTypeEmoji(type: string): string {
  const map: Record<string, string> = {
    'security-update': 'Security',
    'dependency-update': 'Dependency Update',
    'grouped-update': 'Grouped Update',
    'migration': 'Migration',
  };
  return map[type] ?? 'Update';
}

function getPRTypeLabel(type: string): string {
  return getPRTypeEmoji(type);
}

function buildSummarySection(plan: PRPlan): string {
  const lines: string[] = [];
  lines.push('### Summary');
  lines.push('');
  lines.push(`This PR contains **${plan.items.length}** change(s).`);
  return lines.join('\n');
}

function buildSecurityItemSection(
  item: Extract<PRItemKind, { kind: 'security' }>,
): string {
  const u = item.update;
  const lines: string[] = [];
  lines.push(`### ${u.packageName}: ${u.currentVersion} -> ${u.targetVersion}`);
  lines.push('');
  lines.push(`| Dimension | Score |`);
  lines.push(`|-----------|-------|`);
  lines.push(`| Security | ${u.impactScores.security}/10 |`);
  lines.push(`| Urgency | **${u.urgency}** |`);
  lines.push(`| Breaking Risk | ${u.breakingRisk} |`);
  lines.push(`| Estimated Effort | ${u.estimatedEffort}h |`);
  if (u.vulnFixCount > 0) {
    lines.push(`| Vulnerabilities Fixed | ${u.vulnFixCount} |`);
  }
  return lines.join('\n');
}

function buildUpdateItemSection(
  item: Extract<PRItemKind, { kind: 'update' }>,
): string {
  const u = item.update;
  const lines: string[] = [];
  lines.push(`### ${u.packageName}: ${u.currentVersion} -> ${u.targetVersion}`);
  lines.push('');
  lines.push(`- **Update type:** ${u.updateType}`);
  lines.push(`- **Breaking risk:** ${u.breakingRisk}`);
  lines.push(`- **Estimated effort:** ${u.estimatedEffort}h`);
  if (u.hasBreakingChanges && u.breakingChangeSummary) {
    lines.push('');
    lines.push(`> **Breaking Changes:** ${u.breakingChangeSummary}`);
  }
  return lines.join('\n');
}

function buildMigrationItemSection(
  item: Extract<PRItemKind, { kind: 'migration' }>,
): string {
  const rec = item.recommendation;
  const lines: string[] = [];
  lines.push(`### Replace ${rec.currentImplementation.patternCategory} with ${rec.recommendedLibrary.name}`);
  lines.push('');
  lines.push(`- **File:** ${rec.currentImplementation.filePath}`);
  lines.push(`- **Lines:** ${rec.currentImplementation.lineRange.start}-${rec.currentImplementation.lineRange.end}`);
  lines.push(`- **Domain:** ${rec.domain}`);
  lines.push(`- **Migration risk:** ${rec.migrationRisk}`);
  lines.push(`- **Estimated effort:** ${rec.estimatedEffort}h`);
  lines.push(`- **Verification:** ${rec.verificationStatus}`);
  lines.push('');
  lines.push(`| Dimension | Score |`);
  lines.push(`|-----------|-------|`);
  lines.push(`| Composite | ${rec.impactScores.composite}/10 |`);
  lines.push(`| Security | ${rec.impactScores.security}/10 |`);
  lines.push(`| Maintainability | ${rec.impactScores.maintainability}/10 |`);
  lines.push(`| Performance | ${rec.impactScores.performance}/10 |`);

  if (rec.adapterStrategy) {
    lines.push('');
    lines.push(`#### Adapter Strategy`);
    lines.push(`- **Wrapper:** \`${rec.adapterStrategy.wrapperInterface}\``);
    lines.push(`- **Legacy code:** \`${rec.adapterStrategy.legacyCode}\``);
    lines.push(`- **Target library:** \`${rec.adapterStrategy.targetLibrary}\``);
  }

  return lines.join('\n');
}
